<document xmlns="http://cnx.rice.edu/cnxml" xmlns:md="http://cnx.rice.edu/mdml">
  <title>Hashing</title>
  <metadata>
  <md:content-id>m29405</md:content-id><md:title>Hashing</md:title>
  <md:abstract/>
  <md:uuid>272d1d03-adf8-4c1d-a428-ee1fda897ebe</md:uuid>
</metadata>

<content>
    <section id="id-665867576841">
      <title>8. Hashing</title>
      <section id="id-354644187773">
        <title>8.1. Introduction to hashing algorithms</title>
        <para id="id3410175">(From Wikipedia, the free encyclopedia)</para>
        <para id="id3410185">Hash algorithms are designed to be fast and to yield few <link url="http://en.wikipedia.org/wiki/Hash_collision">hash collisions</link> in expected input domains. In <link url="http://en.wikipedia.org/wiki/Hash_table">hash tables</link> and <link url="http://en.wikipedia.org/wiki/Data_processing">data processing</link>, collisions inhibit the distinguishing of data, making <link url="http://en.wikipedia.org/wiki/Database_record">records</link> more costly to find.</para>
        <para id="id3410237">A hash algorithm must be <link url="http://en.wikipedia.org/wiki/Deterministic_algorithm">deterministic</link>, i.e. if two hashes generated by some hash function are different, then the two inputs were different in some way.</para>
        <para id="id3410255">Hash algorithms are usually not <link url="http://en.wikipedia.org/wiki/Injective_function">injective</link>, i.e. the computed hash value may be the same for different input values. This is because it is usually a requirement that the hash value can be stored in fewer bits than the data being hashed. It is a design goal of hash functions to minimize the likelihood of such a <link url="http://en.wikipedia.org/wiki/Hash_collision">hash collision</link> occurring.</para>
        <para id="id3410287">A desirable property of a hash function is the mixing property: a small change in the input (e.g. one bit) should cause a large change in the output (e.g. about half of the bits). This is called the <link url="http://en.wikipedia.org/wiki/Avalanche_effect">avalanche effect</link>.</para>
        <para id="id3410306">Typical hash functions have an <link url="http://en.wikipedia.org/wiki/Infinite">infinite</link><link url="http://en.wikipedia.org/wiki/Domain_%28mathematics%29">domain</link>, such as <link url="http://en.wikipedia.org/wiki/Byte">byte</link><link url="http://en.wikipedia.org/wiki/String_%28computer_science%29">strings</link> of arbitrary length, and a finite range, such as <link url="http://en.wikipedia.org/wiki/Bit">bit</link> sequences of some fixed length. In certain cases, hash functions can be designed with <link url="http://en.wikipedia.org/wiki/One-to-one">one-to-one</link> mapping between identically sized domain and range. Hash functions that are <link url="http://en.wikipedia.org/wiki/One-to-one">one-to-one</link> are also called <link url="http://en.wikipedia.org/wiki/Permutations">permutations</link>. Reversibility is achieved by using a series of <link url="http://en.wikipedia.org/wiki/Reversible">reversible</link> "mixing" operations on the function input.</para>
      </section>
      <section id="id-988298300846">
        <title>8.2. Hash list</title>
        <para id="id3410428">(From Wikipedia, the free encyclopedia)</para>
        <para id="id3410438">In computer science, a hash list is typically a list of hashes of the data blocks in a file or set of files. Lists of hashes are used for many different purposes, such as fast table lookup (hash tables) and distributed databases (distributed hash tables). This article covers hash lists that are used to guarantee data integrity.</para>
        <para id="id3410459">
          <figure id="id3410469"><media id="id7730584" alt=""><image src="../../media/Picture 1-cf9d.png" mime-type="image/png" height="160" width="270"/></media>
          <caption>A hash list with a top hash</caption></figure>
        </para>
        
        <para id="id3410497">A hash list is an extension of the old concept of hashing an item (for instance, a file). A hash list is usually sufficient for most needs, but a more advanced form of the concept is a hash tree.</para>
        <para id="id3410504">Hash lists can be used to protect any kind of data stored, handled and transferred in and between computers. Currently the main use of hash lists is to make sure that data blocks received from other peers in a peer-to-peer network are received undamaged and unaltered, and to check that the other peers do not "lie" and send fake blocks.</para>
        <para id="id3410514">Usually a cryptographic hash function such as SHA-1 is used for the hashing. If the hash list only needs to protect against unintentional damage less secure checksums such as CRCs can be used.</para>
        <para id="id3410522">Hash lists are better than a simple hash of the entire file since, in the case of a data block being damaged, this is noticed, and only the damaged block needs to be redownloaded. With only a hash of the file, the whole file would have to be redownloaded instead, since it would be impossible to determine which part of the file was damaged. Hash lists also protect against nodes that try to sabotage by sending fake blocks, since in such a case the damaged block can be acquired from some other source.</para>
        <para id="id3410534">Often, an additional hash of the hash list itself (a top hash, also called root hash or master hash) is used. Before downloading a file on a p2p network, in most cases the top hash is acquired from a trusted source, for instance a friend or a web site that is known to have good recommendations of files to download. When the top hash is available, the hash list can be received from any non-trusted source, like any peer in the p2p network. Then the received hash list is checked against the trusted top hash, and if the hash list is damaged or fake, another hash list from another source will be tried until the program finds one that matches the top hash.</para>
      </section>
      <section id="id-424938023783">
        <title>8.3. Hash table</title>
        <para id="id3410587">(From Wikipedia, the free encyclopedia)</para>
        <para id="id3410597">In computer science, a hash table, or a hash map, is a data structure that associates keys with values. The primary operation it supports efficiently is a lookup: given a key (e.g. a person's name), find the corresponding value (e.g. that person's telephone number). It works by transforming the key using a hash function into a hash, a number that is used to index into an array to locate the desired location ("bucket") where the values should be.</para>
        <para id="id3410663">Hash tables support the efficient addition of new entries, and the time spent searching for the required data is independent of the number of items stored (i.e. O(1).)</para>
        <para id="id3410670">
          <figure id="id3410679"><media id="id1163999303531" alt=""><image src="../../media/Picture 11-cdfb.png" mime-type="image/png" height="203" width="378"/></media>
          <caption>A small phone book as a hash table</caption></figure>
        </para>
        
        <para id="id3410708">Choosing a good hash function</para>
        <para id="id3410726">A good hash function is essential for good hash table performance. A poor choice of a hash function is likely to lead to clustering, in which probability of keys mapping to the same hash bucket (i.e. a collision) is significantly greater than would be expected from a random function. A nonzero collision probability is inevitable in any hash implementation, but usually the number of operations required to resolve a collision scales linearly with the number of keys mapping to the same bucket, so excess collisions will degrade performance significantly. In addition, some hash functions are computationally expensive, so the amount of time (and, in some cases, memory) taken to compute the hash may be burdensome.</para>
        <para id="id3410762">Choosing a good hash function is tricky. Simplicity and speed are readily measured objectively (by number of lines of code and CPU benchmarks, for example), but strength is a more slippery concept. Obviously, a cryptographic hash function such as SHA-1 would satisfy the relatively lax strength requirements needed for hash tables, but their slowness and complexity makes them unappealing. However, using cryptographic hash functions can protect against collision attacks when the hash table modulus and its factors can be kept secret from the attacker or alternatively, by applying a secret salt. However, for these specialized cases, a universal hash function can be used instead of one static hash.</para>
        <para id="id3410778">In the absence of a standard measure for hash function strength, the current state of the art is to employ a battery of statistical tests to measure whether the hash function can be readily distinguished from a random function. Arguably the most important test is to determine whether the hash function displays the avalanche effect, which essentially states that any single-bit change in the input key should affect on average half the bits in the output. Bret Mulvey advocates testing the strict avalanche condition in particular, which states that, for any single-bit change, each of the output bits should change with probability one-half, independent of the other bits in the key. Purely additive hash functions such as CRC fail this stronger condition miserably.</para>
        <para id="id3410806">Clearly, a strong hash function should have a uniform distribution of hash values. Bret Mulvey proposes the use of a chi-squared test for uniformity, based on power of two hash table sizes ranging from 21 to 216. This test is considerably more sensitive than many others proposed for measuring hash functions, and finds problems in many popular hash functions.</para>
        <para id="id3410837">Fortunately, there are good hash functions that satisfy all these criteria. The simplest class all consume one byte of the input key per iteration of the inner loop. Within this class, simplicity and speed are closely related, as fast algorithms simply don't have time to perform complex calculations.</para>
        <para id="id3410846">A mathematical byte-by-byte implementation that performs particularly well is the Jenkins One-at-a-time hash, adapted here from an article by Bob Jenkins, its creator.</para>
        <para id="id3410853">uint32 joaat_hash(uchar *key, size_t key_len)</para>
        <para id="id3410860">{</para>
        <para id="id3410865">uint32 hash = 0;</para>
        <para id="id3410872">size_t i;</para>
        <para id="id3410883">for (i = 0; i &lt; key_len; i++) {</para>
        <para id="id3410891">hash += key[i];</para>
        <para id="id3410898">hash += (hash &lt;&lt; 10);</para>
        <para id="id3410906">hash ^= (hash &gt;&gt; 6);</para>
        <para id="id3410914">}</para>
        <para id="id3410921">hash += (hash &lt;&lt; 3);</para>
        <para id="id3410929">hash ^= (hash &gt;&gt; 11);</para>
        <para id="id3410936">hash += (hash &lt;&lt; 15);</para>
        <para id="id3410943">return hash;</para>
        <para id="id3410950">}</para>
        <para id="id3410955">
          <figure id="id3410965"><media id="id4968804" alt=""><image src="../../media/Picture 4-571d.png" mime-type="image/png" height="199" width="266"/></media>
          <caption>Avalanche behavior of Jenkins One-at-a-time hash over 3-byte keys</caption></figure>
        </para>
        
        <para id="id3410994">The avalanche behavior of this hash is shown on the right. The image was made using Bret Mulvey's AvalancheTest in his Hash.cs toolset.</para>
        <para id="id3411001">Each of the 24 rows corresponds to a single bit in the 3-byte input key, and each of the 32 columns corresponds to a bit in the output hash. Colors are chosen by how well the input key bit affects the given output hash bit: a green square indicates good mixing behavior, a yellow square weak mixing behavior, and red would indicate no mixing. Only a few bits in the last byte of the output hash are weakly mixed, a performance vastly better than a number of widely used hash functions.</para>
        <para id="id3411013">Many commonly used hash functions perform poorly when subjected to such rigorous avalanche testing. The widely favored FNV hash, for example, shows many bits with no mixing at all, especially for short keys. See the evaluation of FNV by Bret Mulvey for a more thorough analysis.</para>
        <para id="id3411022">If speed is more important than simplicity, then the class of hash functions which consume multibyte chunks per iteration may be of interest. One of the most sophisticated is "lookup3" by Bob Jenkins, which consumes input in 12 byte (96 bit) chunks. Note, though, that any speed improvement from the use of this hash is only likely to be useful for large keys, and that the increased complexity may also have speed consequences such as preventing an optimizing compiler from inlining the hash function. Bret Mulvey analyzed an earlier version, lookup2, and found it to have excellent avalanche behavior.</para>
        <para id="id3411037">One desirable property of a hash function is that conversion from the hash value (typically 32 bits) to a bucket index for a particular-size hash table can be done simply by masking, preserving only the lower k bits for a table of size 2k (an operation equivalent to computing the hash value modulo the table size). This property enables the technique of incremental doubling of the size of the hash table - each bucket in the old table maps to only two in the new table. Because of its use of XOR-folding, the FNV hash does not have this property. Some older hashes are even worse, requiring table sizes to be a prime number rather than a power of two, again computing the bucket index as the hash value modulo the table size. In general, such a requirement is a sign of a fundamentally weak function; using a prime table size is a poor substitute for using a stronger function.</para>
        <para id="id3411067">Collision resolution</para>
        <para id="id3411079">If two keys hash to the same index, the corresponding records cannot be stored in the same location. So, if it's already occupied, we must find another location to store the new record, and do it so that we can find it when we look it up later on.</para>
        <para id="id3411087">To give an idea of the importance of a good collision resolution strategy, consider the following result, derived using the birthday paradox. Even if we assume that our hash function outputs random indices uniformly distributed over the array, and even for a hash table with 1 million indices, there is a 95% chance of at least one collision occurring before it contains 2500 records.</para>
        <para id="id3411098">There are a number of collision resolution techniques, but the most popular are chaining and open addressing.</para>
        <para id="id3411284">Chaining</para>
        <para id="id3411295">
          <figure id="id3411304"><media id="id1163996414938" alt=""><image src="../../media/Picture 7-2ca7.png" mime-type="image/png" height="203" width="378"/></media>
          <caption>Hash collision resolved by chaining</caption></figure>
        </para>
        
        <para id="id3411333">In the simplest chained hash table technique, each slot in the array references a linked list of inserted records that collide to the same slot. Insertion requires finding the correct slot, and appending to either end of the list in that slot; deletion requires searching the list and removal.</para>
        <para id="id3411342">Chained hash tables have advantages over open addressed hash tables in that the removal operation is simple and resizing the table can be postponed for a much longer time because performance degrades more gracefully even when every slot is used. Indeed, many chaining hash tables may not require resizing at all since performance degradation is linear as the table fills. For example, a chaining hash table containing twice its recommended capacity of data would only be about twice as slow on average as the same table at its recommended capacity.</para>
        <para id="id3411356">Chained hash tables inherit the disadvantages of linked lists. When storing small records, the overhead of the linked list can be significant. An additional disadvantage is that traversing a linked list has poor cache performance.</para>
        <para id="id3411364">Alternative data structures can be used for chains instead of linked lists. By using a self-balancing tree, for example, the theoretical worst-case time of a hash table can be brought down to O(log n) rather than O(n). However, since each list is intended to be short, this approach is usually inefficient unless the hash table is designed to run at full capacity or there are unusually high collision rates, as might occur in input designed to cause collisions. Dynamic arrays can also be used to decrease space overhead and improve cache performance when records are small.</para>
        <para id="id3411398">Some chaining implementations use an optimization where the first record of each chain is stored in the table. The purpose is to increase cache efficiency of hash table access. In order to avoid wasting large amounts of space, such hash tables would maintain a load factor of 1.0 or greater.</para>
        <para id="id3411418">Open addressing</para>
        <para id="id3411430">
          <figure id="id3411439"><media id="id8535453" alt=""><image src="../../media/Picture 9.png" mime-type="image/png" height="237" width="378"/></media>
          <caption>Hash collision resolved by linear probing (interval=1)</caption></figure>
        </para>
        
        <para id="id3411469">Open addressing hash tables store the records directly within the array. This approach is also called closed hashing. A hash collision is resolved by probing, or searching through alternate locations in the array (the probe sequence) until either the target record is found, or an unused array slot is found, which indicates that there is no such key in the table. <link url="http://en.wikipedia.org/wiki/Hash_table#_note-tenenbaum90">[2]</link> Well known probe sequences include:</para>
        <para id="id3411523">linear probing </para>
        <para id="id3411527">in which the interval between probes is fixed--often at 1.</para>
        <para id="id3411533">quadratic probing </para>
        <para id="id3411538">in which the interval between probes increases linearly (hence, the indices are described by a quadratic function).</para>
        <para id="id3411544">double hashing </para>
        <para id="id3411548">in which the interval between probes is fixed for each record but is computed by another hash function.</para>
        <para id="id3411554">The main tradeoffs between these methods are that linear probing has the best cache performance but is most sensitive to clustering, while double hashing has poor cache performance but exhibits virtually no clustering; quadratic probing falls in-between in both areas. Double hashing can also require more computation than other forms of probing. Some open addressing methods, such as last-come-first-served hashing and cuckoo hashing move existing keys around in the array to make room for the new key. This gives better maximum search times than the methods based on probing.</para>
        <para id="id3411568">A critical influence on performance of an open addressing hash table is the load factor; that is, the proportion of the slots in the array that are used. As the load factor increases towards 100%, the number of probes that may be required to find or insert a given key rises dramatically. Once the table becomes full, probing algorithms may even fail to terminate. Even with good hash functions, load factors are normally limited to 80%. A poor hash function can exhibit poor performance even at very low load factors by generating significant clustering. What causes hash functions to cluster is not well understood, and it is easy to unintentionally write a hash function which causes severe clustering.</para>
        <para id="id3411596">Example pseudocode</para>
        <para id="id3411607">The following pseudocode is an implementation of an open addressing hash table with linear probing and single-slot stepping, a common approach that is effective if the hash function is good. Each of the lookup, set and remove functions use a common internal function findSlot to locate the array slot that either does or should contain a given key.</para>
        <para id="id3411654">record pair { key, value }</para>
        <para id="id3411671">var pair array slot[0..num_slots-1]</para>
        <para id="id3411696">function find_slot(key)</para>
        <para id="id3411712">i := hash(key) modulo num_slots</para>
        <para id="id3411720">// search until we either find the key, or find an empty slot.</para>
        <para id="id3411734">while ( (slot[i] is occupied) and ( slot[i].key ≠ key ) ) do</para>
        <para id="id3411766">i := (i + 1) modulo num_slots</para>
        <para id="id3411773">repeat</para>
        <para id="id3411787">return i</para>
        <para id="id3411808">function lookup(key)</para>
        <para id="id3411824">i := find_slot(key)</para>
        <para id="id3411832">if slot[i] is occupied // key is in table</para>
        <para id="id3411858">return slot[i].value</para>
        <para id="id3411876">else // key is not in table</para>
        <para id="id3411901">return not found </para>
        <para id="id3411923">function set(key, value)</para>
        <para id="id3411939">i := find_slot(key)</para>
        <para id="id3411947">if slot[i] is occupied</para>
        <para id="id3411965">slot[i].value := value</para>
        <para id="id3411973">else</para>
        <para id="id3411986">if the table is almost full</para>
        <para id="id3412004">rebuild the table larger (note 1)</para>
        <para id="id3412020">i := find_slot(key)</para>
        <para id="id3412028">slot[i].key := key</para>
        <para id="id3412040">slot[i].value := value</para>
        <para id="id3412047">Another example showing open addressing technique. Presented function is converting each part(4) of an internet protocol address, where NOT is bitwise NOT, XOR is bitwise XOR, OR is bitwise OR, AND is bitwise AND and &lt;&lt; and &gt;&gt; are shift-left and shift-right:</para>
        <para id="id3412059">// key_1,key_2,key_3,key_4 are following 3-digit numbers - parts of ip address xxx.xxx.xxx.xxx</para>
        <para id="id3412072">function ip(key parts)</para>
        <para id="id3412088">j := 1</para>
        <para id="id3412096">do</para>
        <para id="id3412109">key := (key_2 &lt;&lt; 2)</para>
        <para id="id3412117">key := (key + (key_3 &lt;&lt; 7))</para>
        <para id="id3412125">key := key + (j OR key_4 &gt;&gt; 2) * (key_4) * (j + key_1) XOR j</para>
        <para id="id3412135">key := key AND _prime_ // _prime_ is a prime number</para>
        <para id="id3412153">j := (j+1) </para>
        <para id="id3412161">while collision</para>
        <para id="id3412179">return key</para>
        <para id="id3412197">Rebuilding the table requires allocating a larger array and recursively using the set operation to insert all the elements of the old array into the new larger array. It is common to increase the array size exponentially, for example by doubling the old array size.</para>
        <para id="id3412217">function remove(key)</para>
        <para id="id3412233">i := find_slot(key)</para>
        <para id="id3412240">if slot[i] is unoccupied</para>
        <para id="id3412258">return // key is not in the table</para>
        <para id="id3412277">j := i</para>
        <para id="id3412284">loop</para>
        <para id="id3412298">j := (j+1) modulo num_slots</para>
        <para id="id3412306">if slot[j] is unoccupied</para>
        <para id="id3412324">exit loop</para>
        <para id="id3412337">k := hash(slot[j].key) modulo num_slots</para>
        <para id="id3412345">if (j &gt; i and (k &lt;= i or k &gt; j)) or</para>
        <para id="id3412384">(j &lt; i and (k &lt;= i and k &gt; j)) (note 2)</para>
        <para id="id3412416">slot[i] := slot[j]</para>
        <para id="id3412424">i := j</para>
        <para id="id3412432">mark slot[i] as unoccupied</para>
        <para id="id3412439">For all records in a cluster, there must be no vacant slots between their natural hash position and their current position (else lookups will terminate before finding the record). At this point in the pseudocode, i is a vacant slot that might be invalidating this property for subsequent records in the cluster. j is such a subsequent record. k is the raw hash where the record at j would naturally land in the hash table if there were no collisions. This test is asking if the record at j is invalidly positioned with respect to the required properties of a cluster now that i is vacant.</para>
        <para id="id3412506">Another technique for removal is simply to mark the slot as deleted. However this eventually requires rebuilding the table simply to remove deleted records. The methods above provide O(1) updating and removal of existing records, with occasional rebuilding if the high water mark of the table size grows.</para>
        <para id="id3412516">The O(1) remove method above is only possible in linearly probed hash tables with single-slot stepping. In the case where many records are to be deleted in one operation, marking the slots for deletion and later rebuilding may be more efficient.</para>
        <para id="id3412524">Open addressing versus chaining</para>
        <para id="id3412534">Chained hash tables have the following benefits over open addressing:</para>
        <list id="id3412540" list-type="bulleted">
          <item>They are simple to implement effectively and only require basic data structures.</item>
          <item>From the point of view of writing suitable hash functions, chained hash tables are insensitive to clustering, only requiring minimization of collisions. Open addressing depends upon better hash functions to avoid clustering. This is particularly important if novice programmers can add their own hash functions, but even experienced programmers can be caught out by unexpected clustering effects.</item>
          <item>They degrade in performance more gracefully. Although chains grow longer as the table fills, a chained hash table cannot "fill up" and does not exhibit the sudden increases in lookup times that occur in a near-full table with open addressing. (see right)</item>
          <item>If the hash table stores large records, about 5 or more words per record, chaining uses less memory than open addressing.</item>
          <item>If the hash table is sparse (that is, it has a big array with many free array slots), chaining uses less memory than open addressing even for small records of 2 to 4 words per record due to its external storage.</item>
        </list>
        <para id="id3412599">
          <figure id="id3412609"><media id="id5367242" alt=""><image src="../../media/Picture 111.png" mime-type="image/png" height="244" width="377"/></media>
          <caption>This graph compares the average number of cache misses required to lookup elements in tables with chaining and linear probing. As the table passes the 80%-full mark, linear probing's performance drastically degrades</caption></figure>
        </para>
        
        <para id="id3412641">For small record sizes (a few words or less) the benefits of in-place open addressing compared to chaining are:</para>
        <list id="id3412647" list-type="bulleted">
          <item>They can be more space-efficient than chaining since they don't need to store any pointers or allocate any additional space outside the hash table. Simple linked lists require a word of overhead per element.</item>
          <item>Insertions avoid the time overhead of memory allocation, and can even be implemented in the absence of a memory allocator.</item>
          <item>Because it uses internal storage, open addressing avoids the extra indirection required for chaining's external storage. It also has better locality of reference, particularly with linear probing. With small record sizes, these factors can yield better performance than chaining, particularly for lookups.</item>
          <item>They can be easier to serialize, because they don't use pointers.</item>
        </list>
        <para id="id3412683">On the other hand, normal open addressing is a poor choice for large elements, since these elements fill entire cache lines (negating the cache advantage), and a large amount of space is wasted on large empty table slots. If the open addressing table only stores references to elements (external storage), it uses space comparable to chaining even for large records but loses its speed advantage.</para>
        <para id="id3412694">Generally speaking, open addressing is better used for hash tables with small records that can be stored within the table (internal storage) and fit in a cache line. They are particularly suitable for elements of one word or less. In cases where the tables are expected to have high load factors, the records are large, or the data is variable-sized, chained hash tables often perform as well or better.</para>
        <para id="id3412705">Ultimately, used sensibly any kind of hash table algorithm is usually fast enough; and the percentage of a calculation spent in hash table code is low. Memory usage is rarely considered excessive. Therefore, in most cases the differences between these algorithms is marginal, and other considerations typically come into play.</para>
        <para id="id3412727">Coalesced hashing</para>
        <para id="id3412738">A hybrid of chaining and open addressing, coalesced hashing links together chains of nodes within the table itself. Like open addressing, it achieves space usage and (somewhat diminished) cache advantages over chaining. Like chaining, it does not exhibit clustering effects; in fact, the table can be efficiently filled to a high density. Unlike chaining, it cannot have more elements than table slots.</para>
        <para id="id3412749">Perfect hashing</para>
        <para id="id3412760">If all of the keys that will be used are known ahead of time, and there are no more keys than can fit the hash table, perfect hashing can be used to create a perfect hash table, in which there will be no collisions. If minimal perfect hashing is used, every location in the hash table can be used as well.</para>
        <para id="id3412770">Perfect hashing gives a hash table where the time to make a lookup is constant in the worst case. This is in contrast to chaining and open addressing methods, where the time for lookup is low on average, but may be arbitrarily large. There exist methods for maintaining a perfect hash function under insertions of keys, known as dynamic perfect hashing. A simpler alternative, that also gives worst case constant lookup time, is cuckoo hashing.</para>
        <para id="id3412782">Probabilistic hashing</para>
        <para id="id3412793">Perhaps the simplest solution to a collision is to replace the value that is already in the slot with the new value, or slightly less commonly, drop the record that is to be inserted. In later searches, this may result in a search not finding a record which has been inserted. This technique is particularly useful for implementing caching.</para>
        <para id="id3412803">An even more space-efficient solution which is similar to this is use a bit array (an array of one-bit fields) for our table. Initially all bits are set to zero, and when we insert a key, we set the corresponding bit to one. False negatives cannot occur, but false positives can, since if the search finds a 1 bit, it will claim that the value was found, even if it was just another value that hashed into the same array slot by coincidence. In reality, such a hash table is merely a specific type of Bloom filter.</para>
        <para id="id3412816">Robin Hood hashing</para>
        <para id="id3412828">One interesting variation on double-hashing collision resolution is that of Robin Hood hashing. The idea is that a key already inserted may be displaced by a new key if its probe count is larger than the key at the current position. The net effect of this is that it reduces worst case search times in the table. This is similar to Knuth's ordered hash tables except the criteria for bumping a key does not depend on a direct relationship between the keys. </para>
        <para id="id3412840">Table resizing</para>
        <para id="id3412851">With a good hash function, a hash table can typically contain about 70%–80% as many elements as it does table slots and still perform well. Depending on the collision resolution mechanism, performance can begin to suffer either gradually or dramatically as more elements are added. To deal with this, when the load factor exceeds some threshold, it is necessary to allocate a new, larger table, and add all the contents of the original table to this new table. In Java's HashMap class, for example, the default load factor threshold is 0.75.</para>
        <para id="id3412868">This can be a very expensive operation, and the necessity for it is one of the hash table's disadvantages. In fact, some naive methods for doing this, such as enlarging the table by one each time you add a new element, reduce performance so drastically as to make the hash table useless. However, if the table is enlarged by some fixed percent, such as 10% or 100%, it can be shown using amortized analysis that these resizings are so infrequent that the average time per lookup remains constant-time. To see why this is true, suppose a hash table using chaining begins at the minimum size of 1 and is doubled each time it fills above 100%. If in the end it contains n elements, then the total add operations performed for all the resizings is:</para>
        <para id="id3412896">1 + 2 + 4 + ... + n = 2n - 1.</para>
        <para id="id3412920">Because the costs of the resizings form a geometric series, the total cost is O(n). But it is necessary also to perform n operations to add the n elements in the first place, so the total time to add n elements with resizing is O(n), an amortized time of O(1) per element.</para>
        <para id="id3412974">On the other hand, some hash table implementations, notably in real-time systems, cannot pay the price of enlarging the hash table all at once, because it may interrupt time-critical operations. One simple approach is to initially allocate the table with enough space for the expected number of elements and forbid the addition of too many elements. Another useful but more memory-intensive technique is to perform the resizing gradually:</para>
        <list id="id3412985" list-type="bulleted">
          <item>Allocate the new hash table, but leave the old hash table and check both tables during lookups.</item>
          <item>Each time an insertion is performed, add that element to the new table and also move k elements from the old table to the new table.</item>
          <item>When all elements are removed from the old table, deallocate it.</item>
        </list>
        <para id="id3413021">To ensure that the old table will be completely copied over before the new table itself needs to be enlarged, it's necessary to increase the size of the table by a factor of at least (k + 1)/k during the resizing.</para>
        <para id="id3413049">Linear hashing is a hash table algorithm that permits incremental hash table expansion. It is implemented using a single hash table, but with two possible look-up functions.</para>
        <para id="id3413056">Another way to decrease the cost of table resizing is to choose a hash function in such a way that the hashes of most values do not change when the table is resized. This approach, called consistent hashing, is prevalent in disk-based and distributed hashes, where resizing is prohibitively costly.</para>
        <para id="id3413065">Ordered retrieval issue</para>
        <para id="id3413077">Hash tables store data in pseudo-random locations, so accessing the data in a sorted manner is a very time consuming operation. Other data structures such as self-balancing binary search trees generally operate more slowly (since their lookup time is O(log n)) and are rather more complex to implement than hash tables but maintain a sorted data structure at all times. See a comparison of hash tables and self-balancing binary search trees.</para>
        <para id="id3413100">Problems with hash tables</para>
        <para id="id3413112">Although hash table lookups use constant time on average, the time spent can be significant. Evaluating a good hash function can be a slow operation. In particular, if simple array indexing can be used instead, this is usually faster.</para>
        <para id="id3413120">Hash tables in general exhibit poor locality of reference—that is, the data to be accessed is distributed seemingly at random in memory. Because hash tables cause access patterns that jump around, this can trigger microprocessor cache misses that cause long delays. Compact data structures such as arrays, searched with linear search, may be faster if the table is relatively small and keys are cheap to compare, such as with simple integer keys. According to Moore's Law, cache sizes are growing exponentially and so what is considered "small" may be increasing. The optimal performance point varies from system to system; for example, a trial on Parrot shows that its hash tables outperform linear search in all but the most trivial cases (one to three entries).</para>
        <para id="id3413152">More significantly, hash tables are more difficult and error-prone to write and use. Hash tables require the design of an effective hash function for each key type, which in some situations is more difficult and time-consuming to design and debug than the simple comparison function required for a self-balancing binary search tree. In open-addressed hash tables it's fairly easy to create a poor hash function.</para>
        <para id="id3413163">Additionally, in some applications, a black hat with knowledge of the hash function may be able to supply information to a hash which creates worst-case behavior by causing excessive collisions, resulting in very poor performance (i.e., a denial of service attack). In critical applications, either universal hashing can be used or a data structure with better worst-case guarantees may be preferable.</para>
      </section>
      <section id="id-232255016124">
        <title>8.4. Hash tree</title>
        <para id="id3413182">(From Wikipedia, the free encyclopedia)</para>
        <para id="id3413192">In cryptography, hash trees (also known as Merkle trees) are an extension of the simpler concept <link url="http://en.wikipedia.org/wiki/Hash_list">hash list</link>, which in turn is an extension of the old concept of hashing. </para>
        <para id="id3413234">
          <figure id="id3413243"><media id="id1163997237468" alt=""><image src="../../media/Picture 12.png" mime-type="image/png" height="213" width="229"/></media>
          <caption>A binary hash tree</caption></figure>
        </para>
        
        <para id="id3413272">Uses</para>
        <para id="id3413283">Hash trees can be used to protect any kind of data stored, handled and transferred in and between computers. Currently the main use of hash trees is to make sure that data blocks received from other peers in a peer-to-peer network are received undamaged and unaltered, and even to check that the other peers do not lie and send fake blocks. Suggestions have been made to use hash trees in trusted computing systems.</para>
        <para id="id3413294">How hash trees work</para>
        <para id="id3413306">A hash tree is a tree of hashes in which the leaves are hashes of data blocks in, for instance, a file or set of files. Nodes further up in the tree are the hashes of their respective children. For example, in the picture hash 0 is the result of hashing hash 0-0 and then hash 0-1. That is, hash 0 = hash( hash 0-0 | hash 0-1 ).</para>
        <para id="id3413353">Most hash tree implementations are binary (two child nodes under each node) but they can just as well use many more child nodes under each node.</para>
        <para id="id3413359">Usually, a cryptographic hash function such as SHA-1, Whirlpool, or Tiger is used for the hashing. If the hash tree only needs to protect against unintentional damage, the much less secure checksums such as CRCs can be used.</para>
        <para id="id3413367">In the top of a hash tree there is a top hash (or root hash or master hash). Before downloading a file on a p2p network, in most cases the top hash is acquired from a trusted source, for instance a friend or a web site that is known to have good recommendations of files to download. When the top hash is available, the hash tree can be received from any non-trusted source, like any peer in the p2p network. Then, the received hash tree is checked against the trusted top hash, and if the hash tree is damaged or fake, another hash tree from another source will be tried until the program finds one that matches the top hash.</para>
        <para id="id3413411">The main difference from a hash list is that one branch of the hash tree can be downloaded at a time and the integrity of each branch can be checked immediately, even though the whole tree is not available yet. This can be an advantage since it is efficient to split files up in very small data blocks so that only small blocks have to be redownloaded if they get damaged. If the hashed file is very big, such a hash tree or hash list becomes fairly big. But if it is a tree, one small branch can be downloaded quickly, the integrity of the branch can be checked, and then the downloading of data blocks can start.</para>
        <para id="id3413425">There are several additional tricks, benefits and details regarding hash trees. See the references and external links below for more in-depth information.</para>
      </section>
      <section id="id-591881898284">
        <title>8.5. Choosing hash functions</title>
        <para id="id3413440">(From Wikipedia, the free encyclopedia)</para>
        <para id="id3413450">A hash function is a reproducible method of turning some kind of data into a (relatively) small number that may serve as a digital "fingerprint" of the data. The algorithm "chops and mixes" (i.e., substitutes or transposes) the data to create such fingerprints. The fingerprints are called hash sums, hash values, hash codes or simply hashes. (Note that hashes can also mean the hash functions.) Hash sums are commonly used as indices into hash tables or hash files. Cryptographic hash functions are used for various purposes in information security applications.</para>
        <para id="id3413518">
          <figure id="id3413527"><media id="id5648762" alt=""><image src="../../media/Picture 13.png" mime-type="image/png" height="206" width="303"/></media>
          <caption>A typical hash function at work</caption></figure>
        </para>
        
        <para id="id3413556">Properties</para>
        <para id="id3413567">Hash functions are designed to be fast and to yield few hash collisions in expected input domains. In hash tables and data processing, collisions inhibit the distinguishing of data, making records more costly to find.</para>
        <para id="id3413575">A hash function must be deterministic, i.e. if two hashes generated by some hash function are different, then the two inputs were different in some way.</para>
        <para id="id3413582">Hash functions are usually not injective, i.e. the computed hash value may be the same for different input values. This is because it is usually a requirement that the hash value can be stored in fewer bits than the data being hashed. It is a design goal of hash functions to minimize the likelihood of such a hash collision occurring.</para>
        <para id="id3413592">A desirable property of a hash function is the mixing property: a small change in the input (e.g. one bit) should cause a large change in the output (e.g. about half of the bits). This is called the avalanche effect.</para>
        <para id="id3413600">Typical hash functions have an infinite domain, such as byte strings of arbitrary length, and a finite range, such as bit sequences of some fixed length. In certain cases, hash functions can be designed with one-to-one mapping between identically sized domain and range. Hash functions that are one-to-one are also called permutations. Reversibility is achieved by using a series of reversible "mixing" operations on the function input.</para>
        <para id="id3413611">Applications</para>
        <para id="id3413623">Because of the variety of applications for hash functions (details below), they are often tailored to the application. For example, cryptographic hash functions assume the existence of an adversary who can deliberately try to find inputs with the same hash value. A well designed cryptographic hash function is a "one-way" operation: there is no practical way to calculate a particular data input that will result in a desired hash value, so it is also very difficult to forge. Functions intended for cryptographic hashing, such as MD5, are commonly used as stock hash functions.</para>
        <para id="id3413637">Functions for error detection and correction focus on distinguishing cases in which data has been disturbed by random processes. When hash functions are used for checksums, the relatively small hash value can be used to verify that a data file of any size has not been altered.</para>
        <para id="id3413646">Cryptography</para>
        <para id="id3413657">A typical cryptographic one-way function is not one-to-one and makes an effective hash function; a typical cryptographic trapdoor function is one-to-one and makes an effective randomization function.</para>
        <para id="id3413676">Hash tables</para>
        <para id="id3413687">Hash tables, a major application for hash functions, enable fast lookup of a data record given its key. (Note: Keys are not usually secret as in cryptography, but both are used to "unlock" or access information.) For example, keys in an English dictionary would be English words, and their associated records would contain definitions. In this case, the hash function must map alphabetic strings to indexes for the hash table's internal array.</para>
        <para id="id3413711">The ideal for a hash table's hash function is to map each key to a unique index, because this guarantees access to each data record in the first probe into the table. However, this is often impossible or impractical.</para>
        <para id="id3413719">Hash functions that are truly random with uniform output (including most cryptographic hash functions) are good in that, on average, only one or two probes will be needed (depending on the load factor). Perhaps as important is that excessive collision rates with random hash functions are highly improbable—if not computationally infeasible for an adversary. However, a small, predictable number of collisions are virtually inevitable.</para>
        <para id="id3413737">In many cases, a heuristic hash function can yield many fewer collisions than a random hash function. Heuristic functions take advantage of regularities in likely sets of keys. For example, one could design a heuristic hash function such that file names such as FILE0000.CHK, FILE0001.CHK, FILE0002.CHK, etc. map to successive indices of the table, meaning that such sequences will not collide. Beating a random hash function on "good" sets of keys usually means performing much worse on "bad" sets of keys, which can arise naturally—not just through attacks. Bad performance of a hash table's hash function means that lookup can degrade to a costly linear search.</para>
        <para id="id3413764">Aside from minimizing collisions, the hash function for a hash table should also be fast relative to the cost of retrieving a record in the table, as the goal of minimizing collisions is minimizing the time needed to retrieve a desired record. Consequently, the optimal balance of performance characteristics depends on the application.</para>
        <para id="id3413774">Error correction</para>
        <para id="id3413785">Using a hash function to detect errors in transmission is straightforward. The hash function is computed for the data at the sender, and the value of this hash is sent with the data. The hash function is performed again at the receiving end, and if the hash values do not match, an error has occurred at some point during the transmission. This is called a redundancy check.</para>
        <para id="id3413796">For error correction, a distribution of likely perturbations is assumed at least approximately. Perturbations to a string are then classified into large (improbable) and small (probable) errors. The second criterion is then restated so that if we are given H(x) and x+s, then we can compute x efficiently if s is small. Such hash functions are known as error correction codes. Important sub-class of these correction codes are cyclic redundancy checks and Reed-Solomon codes.</para>
        <para id="id3413808">Audio identification</para>
        <para id="id3413826">For audio identification such as finding out whether an MP3 file matches one of a list of known items, one could use a conventional hash function such as MD5, but this would be very sensitive to highly likely perturbations such as time-shifting, CD read errors, different compression algorithms or implementations or changes in volume. Using something like MD5 is useful as a first pass to find exactly identical files, but another more advanced algorithm is required to find all items that would nonetheless be interpreted as identical to a human listener. Though they are not common, hashing algorithms do exist that are robust to these minor differences. Most of the algorithms available are not extremely robust, but some are so robust that they can identify music played on loud-speakers in a noisy room. One example of this in practical use is the service Shazam. Customers call a number and place their telephone near a speaker. The service then analyses the music, and compares it to known hash values in its database. The name of the music is sent to the user. An open source alternative to this service is MusicBrainz which creates a fingerprint for an audio file and matches it to its online community driven database.</para>
      </section>
      <section id="id-318972189118">
        <title>8.6. Universal hashing</title>
        <para id="id3413871">(From Wikipedia, the free encyclopedia)</para>
        <para id="id3413881">Universal hashing is a <link url="http://en.wikipedia.org/wiki/Randomized_algorithm">randomized algorithm</link> for selecting a <link url="http://en.wikipedia.org/wiki/Hash_function">hash function</link> F with the following property: for any two distinct inputs x and y, the probability that F(x)=F(y) (i.e., that there is a <link url="http://en.wikipedia.org/wiki/Hash_collision">hash collision</link> between x and y) is the same as if F was a random function. Thus, if F has function values in a range of size r, the probability of any particular hash collision should be 1/r. There are universal hashing methods that give a function F that can be evaluated in a handful of computer instructions.</para>
      </section>
      <section id="id-833878487095">
        <title>Introduction</title>
        <para id="id3414003"><link url="http://en.wikipedia.org/wiki/Hashing">Hashing</link> has been used to associate with an input, usually a string, a small value that originally was used as an index to look up something about that input in a table. Since then hashing has found other uses. For example, two inputs might be compared by checking to see if their hash values are the same. Thus, we can see that hash functions are many-to-one mappings. The use of the word "hash" is mnemonic because the intent of a hash function is to take as many of the inputs usually encountered and assign different values to them, by scrambling them or making a hash of the inputs, using the meaning of hash from domains such as cooking. If for any given input there are too many collisions that is viewed as unfortunate.</para>
      </section>
      <section id="id-28323898062">
        <title>Universal Hashing</title>
        <para id="id3414048">Because a hash function is a many-to-one mapping, there must exist some set of elements that will collide under the hash function. One wants to design the hash function such that for the input sets, it is unlikely that elements collide. Proving in a mathematical sense that you are unlikely to encounter a particular set of inputs would appear to be an impossible task.</para>
        <para id="id3414058"><link url="http://en.wikipedia.org/wiki/Randomized_algorithms">Randomized algorithms</link> present a way of proving that you are unlikely to encounter a bad set of inputs. We can construct a Universal Class of hash functions with the property that for any given set of inputs they will scatter the inputs among the range of the function well -- essentially as well as choosing random values for those inputs. Thus, simply choosing a random function from the class allows a proof that the probabilistic expectation for any set of inputs is that they will be distributed randomly.</para>
        <para id="id3414087">In fact, we are in many cases interested in only pairwise collisions. That is to say, the odds that any two inputs x and y collide will be approximately the same as the reciprocal of the size of the range. It might be that for any given universal class of hash functions there exist x, y and z such that if x and y collide then so does z. While some work has been done on the set issue, universal hashing only makes statements about pairwise collisions.</para>
      </section>
      <section id="id-989309893">
        <title>Example</title>
        <para id="id3414110">A simple universal class of hash function is all functions h of the form h(x)= f(g(x)), where g(x)=ax+b (mod p) with p being a prime guaranteed larger than any possible input and each combination of a and b forming a different function in the class. f then becomes a mapping function to map elements from a domain which is 0 to p to a range of say 0 to n-1. f then can simply be taking the result of g mod n. There is only one f for all the functions in this class. To see why this class is universal, observe that for any two inputs and any two outputs, there are approximately p/n elements that can map to any output and for any of pair of those p/n elements you can solve the simultaneous equations in the field mod p, so for any pair of inputs there is a unique pair of a and b that will take it to those elements.</para>
        <para id="id3414241">Universal hashing has numerous uses in computer science, for example in cryptography and in implementations of <link url="http://en.wikipedia.org/wiki/Hash_table">hash tables</link>. Since the function is randomly chosen, an adversary hoping to create many <link url="http://en.wikipedia.org/wiki/Hash_collision">hash collisions</link> is unlikely to succeed.</para>
        <para id="id3414273">Universal hashing has been generalized in many ways, most notably to the notion of k-wise independent hash functions, where the function is required to act like a random function on any set of k inputs.</para>
      </section>
      <section id="id-492347671433">
        <title>8.7. Perfect hashing</title>
        <para id="id3414299">(From Wikipedia, the free encyclopedia)</para>
        <para id="id3414309">A Perfect hash function of a set S is a hash function which maps different keys (elements) in S to different numbers. A perfect hash function with values in a range of size some constant times the number of elements in S can be used for efficient lookup operations, by placing the keys in a hash table according to the values of the perfect hash function.</para>
        <para id="id3414331">A perfect hash function for a specific set S that can be evaluated in constant time, and with values in a small range, can be found by a randomized algorithm in a number of operations that is proportional to the size of S. The minimal size of the description of a perfect hash function depends on the range of its function values: The smaller the range, the more space is required. Any perfect hash functions suitable for use with a hash table require at least a number of bits that is proportional to the size of S. Many common implementations require a number of bits that is proportional to n log(n), where n is the size of S. This means that the space for storing the perfect hash function can be comparable to the space for storing the set.</para>
        <para id="id3414376">Using a perfect hash function is best in situations where there is a large set which is not updated frequently, and many lookups into it. Efficient solutions to performing updates are known as dynamic perfect hashing, but these methods are relatively complicated to implement. A simple alternative to perfect hashing, which also allows dynamic updates, is cuckoo hashing.</para>
        <para id="id3414386">A minimal perfect hash function is a perfect hash function that maps n keys to n consecutive integers -- usually [0..n-1] or [1..n]. A more formal way of expressing this is: Let j and k be elements of some set K. F is a minimal perfect hash function if F(j) =F(k) implies j=k and there exists an integer a such that the range of F is a..a+|K|-1.</para>
        <para id="id3414499">A minimal perfect hash function F is order-preserving if for any keys j and k, j&lt;k implies F(j)&lt;F(k).</para>
      </section>
    </section>
  </content>
</document>